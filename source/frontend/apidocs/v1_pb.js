// source: v1.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.AuthToken', null, global);
goog.exportSymbol('proto.BATExecution', null, global);
goog.exportSymbol('proto.BATKeyImport', null, global);
goog.exportSymbol('proto.BATKeygenParameters', null, global);
goog.exportSymbol('proto.BATKeygenResult', null, global);
goog.exportSymbol('proto.BATKeys', null, global);
goog.exportSymbol('proto.BATParameters', null, global);
goog.exportSymbol('proto.CTRUExecution', null, global);
goog.exportSymbol('proto.CTRUKeyImport', null, global);
goog.exportSymbol('proto.CTRUKeygenParameters', null, global);
goog.exportSymbol('proto.CTRUKeygenResult', null, global);
goog.exportSymbol('proto.CTRUKeys', null, global);
goog.exportSymbol('proto.CTRUParameters', null, global);
goog.exportSymbol('proto.Entry', null, global);
goog.exportSymbol('proto.EntryID', null, global);
goog.exportSymbol('proto.LoginCredentials', null, global);
goog.exportSymbol('proto.RegisterCredentials', null, global);
goog.exportSymbol('proto.User', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.LoginCredentials = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.LoginCredentials, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.LoginCredentials.displayName = 'proto.LoginCredentials';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RegisterCredentials = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RegisterCredentials, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.RegisterCredentials.displayName = 'proto.RegisterCredentials';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.AuthToken = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.AuthToken, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.AuthToken.displayName = 'proto.AuthToken';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.User = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.User, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.User.displayName = 'proto.User';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Entry = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Entry, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Entry.displayName = 'proto.Entry';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EntryID = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EntryID, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.EntryID.displayName = 'proto.EntryID';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.BATParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.BATParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.BATParameters.displayName = 'proto.BATParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.BATKeys = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.BATKeys, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.BATKeys.displayName = 'proto.BATKeys';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.BATKeygenResult = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.BATKeygenResult, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.BATKeygenResult.displayName = 'proto.BATKeygenResult';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.BATKeygenParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.BATKeygenParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.BATKeygenParameters.displayName = 'proto.BATKeygenParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.BATExecution = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.BATExecution, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.BATExecution.displayName = 'proto.BATExecution';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.BATKeyImport = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.BATKeyImport, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.BATKeyImport.displayName = 'proto.BATKeyImport';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CTRUParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CTRUParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CTRUParameters.displayName = 'proto.CTRUParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CTRUKeys = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CTRUKeys, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CTRUKeys.displayName = 'proto.CTRUKeys';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CTRUKeygenResult = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CTRUKeygenResult, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CTRUKeygenResult.displayName = 'proto.CTRUKeygenResult';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CTRUKeygenParameters = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CTRUKeygenParameters, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CTRUKeygenParameters.displayName = 'proto.CTRUKeygenParameters';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CTRUExecution = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CTRUExecution, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CTRUExecution.displayName = 'proto.CTRUExecution';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CTRUKeyImport = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CTRUKeyImport, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.CTRUKeyImport.displayName = 'proto.CTRUKeyImport';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.LoginCredentials.prototype.toObject = function(opt_includeInstance) {
  return proto.LoginCredentials.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.LoginCredentials} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoginCredentials.toObject = function(includeInstance, msg) {
  var f, obj = {
    username: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    password: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.LoginCredentials}
 */
proto.LoginCredentials.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.LoginCredentials;
  return proto.LoginCredentials.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.LoginCredentials} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.LoginCredentials}
 */
proto.LoginCredentials.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPassword(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.LoginCredentials.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.LoginCredentials.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.LoginCredentials} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoginCredentials.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * required string username = 1;
 * @return {string}
 */
proto.LoginCredentials.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.LoginCredentials} returns this
 */
proto.LoginCredentials.prototype.setUsername = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.LoginCredentials} returns this
 */
proto.LoginCredentials.prototype.clearUsername = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.LoginCredentials.prototype.hasUsername = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required string password = 2;
 * @return {string}
 */
proto.LoginCredentials.prototype.getPassword = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.LoginCredentials} returns this
 */
proto.LoginCredentials.prototype.setPassword = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.LoginCredentials} returns this
 */
proto.LoginCredentials.prototype.clearPassword = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.LoginCredentials.prototype.hasPassword = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RegisterCredentials.prototype.toObject = function(opt_includeInstance) {
  return proto.RegisterCredentials.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RegisterCredentials} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RegisterCredentials.toObject = function(includeInstance, msg) {
  var f, obj = {
    username: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    emailaddress: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
    password: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RegisterCredentials}
 */
proto.RegisterCredentials.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RegisterCredentials;
  return proto.RegisterCredentials.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RegisterCredentials} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RegisterCredentials}
 */
proto.RegisterCredentials.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setEmailaddress(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPassword(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RegisterCredentials.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RegisterCredentials.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RegisterCredentials} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RegisterCredentials.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * required string username = 1;
 * @return {string}
 */
proto.RegisterCredentials.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.RegisterCredentials} returns this
 */
proto.RegisterCredentials.prototype.setUsername = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.RegisterCredentials} returns this
 */
proto.RegisterCredentials.prototype.clearUsername = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.RegisterCredentials.prototype.hasUsername = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required string emailAddress = 2;
 * @return {string}
 */
proto.RegisterCredentials.prototype.getEmailaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.RegisterCredentials} returns this
 */
proto.RegisterCredentials.prototype.setEmailaddress = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.RegisterCredentials} returns this
 */
proto.RegisterCredentials.prototype.clearEmailaddress = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.RegisterCredentials.prototype.hasEmailaddress = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required string password = 3;
 * @return {string}
 */
proto.RegisterCredentials.prototype.getPassword = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.RegisterCredentials} returns this
 */
proto.RegisterCredentials.prototype.setPassword = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.RegisterCredentials} returns this
 */
proto.RegisterCredentials.prototype.clearPassword = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.RegisterCredentials.prototype.hasPassword = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.AuthToken.prototype.toObject = function(opt_includeInstance) {
  return proto.AuthToken.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.AuthToken} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.AuthToken.toObject = function(includeInstance, msg) {
  var f, obj = {
    userid: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    generatedat: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
    expiresat: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.AuthToken}
 */
proto.AuthToken.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.AuthToken;
  return proto.AuthToken.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.AuthToken} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.AuthToken}
 */
proto.AuthToken.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserid(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setGeneratedat(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExpiresat(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.AuthToken.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.AuthToken.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.AuthToken} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.AuthToken.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * required string userId = 1;
 * @return {string}
 */
proto.AuthToken.prototype.getUserid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.setUserid = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.clearUserid = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.AuthToken.prototype.hasUserid = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required int64 generatedAt = 2;
 * @return {number}
 */
proto.AuthToken.prototype.getGeneratedat = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.setGeneratedat = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.clearGeneratedat = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.AuthToken.prototype.hasGeneratedat = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required int64 expiresAt = 3;
 * @return {number}
 */
proto.AuthToken.prototype.getExpiresat = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.setExpiresat = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.clearExpiresat = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.AuthToken.prototype.hasExpiresat = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required bytes signature = 4;
 * @return {string}
 */
proto.AuthToken.prototype.getSignature = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * required bytes signature = 4;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.AuthToken.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * required bytes signature = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.AuthToken.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.setSignature = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.AuthToken} returns this
 */
proto.AuthToken.prototype.clearSignature = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.AuthToken.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.User.prototype.toObject = function(opt_includeInstance) {
  return proto.User.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.User} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.User.toObject = function(includeInstance, msg) {
  var f, obj = {
    username: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    emailaddress: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
    userid: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.User}
 */
proto.User.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.User;
  return proto.User.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.User} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.User}
 */
proto.User.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setUsername(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setEmailaddress(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserid(value);
      break;
    case 4:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.User.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.User.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.User} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.User.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
};


/**
 * required string username = 1;
 * @return {string}
 */
proto.User.prototype.getUsername = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.User} returns this
 */
proto.User.prototype.setUsername = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.User} returns this
 */
proto.User.prototype.clearUsername = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.User.prototype.hasUsername = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required string emailAddress = 2;
 * @return {string}
 */
proto.User.prototype.getEmailaddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.User} returns this
 */
proto.User.prototype.setEmailaddress = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.User} returns this
 */
proto.User.prototype.clearEmailaddress = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.User.prototype.hasEmailaddress = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required string userId = 3;
 * @return {string}
 */
proto.User.prototype.getUserid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.User} returns this
 */
proto.User.prototype.setUserid = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.User} returns this
 */
proto.User.prototype.clearUserid = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.User.prototype.hasUserid = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional AuthToken token = 4;
 * @return {?proto.AuthToken}
 */
proto.User.prototype.getToken = function() {
  return /** @type{?proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 4));
};


/**
 * @param {?proto.AuthToken|undefined} value
 * @return {!proto.User} returns this
*/
proto.User.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.User} returns this
 */
proto.User.prototype.clearToken = function() {
  return this.setToken(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.User.prototype.hasToken = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Entry.prototype.toObject = function(opt_includeInstance) {
  return proto.Entry.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Entry} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Entry.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    userid: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
    algorithmname: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
    functionname: (f = jspb.Message.getField(msg, 4)) == null ? undefined : f,
    inputparametersMap: (f = msg.getInputparametersMap()) ? f.toObject(includeInstance, undefined) : [],
    keyid: (f = jspb.Message.getField(msg, 6)) == null ? undefined : f,
    executiontime: (f = jspb.Message.getField(msg, 7)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Entry}
 */
proto.Entry.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Entry;
  return proto.Entry.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Entry} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Entry}
 */
proto.Entry.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUserid(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setAlgorithmname(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setFunctionname(value);
      break;
    case 5:
      var value = msg.getInputparametersMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readUint64, null, "", 0);
         });
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setKeyid(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setExecutiontime(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Entry.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Entry.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Entry} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Entry.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getInputparametersMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeUint64);
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeInt64(
      7,
      f
    );
  }
};


/**
 * optional string id = 1;
 * @return {string}
 */
proto.Entry.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.setId = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.clearId = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Entry.prototype.hasId = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string userId = 2;
 * @return {string}
 */
proto.Entry.prototype.getUserid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.setUserid = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.clearUserid = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Entry.prototype.hasUserid = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required string algorithmName = 3;
 * @return {string}
 */
proto.Entry.prototype.getAlgorithmname = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.setAlgorithmname = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.clearAlgorithmname = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Entry.prototype.hasAlgorithmname = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required string functionName = 4;
 * @return {string}
 */
proto.Entry.prototype.getFunctionname = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.setFunctionname = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.clearFunctionname = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Entry.prototype.hasFunctionname = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * map<string, uint64> inputParameters = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,number>}
 */
proto.Entry.prototype.getInputparametersMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,number>} */ (
      jspb.Message.getMapField(this, 5, opt_noLazyCreate,
      null));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.clearInputparametersMap = function() {
  this.getInputparametersMap().clear();
  return this;};


/**
 * required string keyId = 6;
 * @return {string}
 */
proto.Entry.prototype.getKeyid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * @param {string} value
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.setKeyid = function(value) {
  return jspb.Message.setField(this, 6, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.clearKeyid = function() {
  return jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Entry.prototype.hasKeyid = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * required int64 executionTime = 7;
 * @return {number}
 */
proto.Entry.prototype.getExecutiontime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.setExecutiontime = function(value) {
  return jspb.Message.setField(this, 7, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.Entry} returns this
 */
proto.Entry.prototype.clearExecutiontime = function() {
  return jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Entry.prototype.hasExecutiontime = function() {
  return jspb.Message.getField(this, 7) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EntryID.prototype.toObject = function(opt_includeInstance) {
  return proto.EntryID.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EntryID} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EntryID.toObject = function(includeInstance, msg) {
  var f, obj = {
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f),
    entryid: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EntryID}
 */
proto.EntryID.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EntryID;
  return proto.EntryID.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EntryID} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EntryID}
 */
proto.EntryID.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setEntryid(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EntryID.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EntryID.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EntryID} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EntryID.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * required AuthToken token = 1;
 * @return {!proto.AuthToken}
 */
proto.EntryID.prototype.getToken = function() {
  return /** @type{!proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 1, 1));
};


/**
 * @param {!proto.AuthToken} value
 * @return {!proto.EntryID} returns this
*/
proto.EntryID.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.EntryID} returns this
 */
proto.EntryID.prototype.clearToken = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.EntryID.prototype.hasToken = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required string entryId = 2;
 * @return {string}
 */
proto.EntryID.prototype.getEntryid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.EntryID} returns this
 */
proto.EntryID.prototype.setEntryid = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.EntryID} returns this
 */
proto.EntryID.prototype.clearEntryid = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.EntryID.prototype.hasEntryid = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.BATParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.BATParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.BATParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    n: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    b: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
    k: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
    q: (f = jspb.Message.getField(msg, 4)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.BATParameters}
 */
proto.BATParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.BATParameters;
  return proto.BATParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.BATParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.BATParameters}
 */
proto.BATParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setN(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setB(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setK(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setQ(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.BATParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.BATParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.BATParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeInt64(
      4,
      f
    );
  }
};


/**
 * required int64 n = 1;
 * @return {number}
 */
proto.BATParameters.prototype.getN = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.setN = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.clearN = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATParameters.prototype.hasN = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required int64 b = 2;
 * @return {number}
 */
proto.BATParameters.prototype.getB = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.setB = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.clearB = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATParameters.prototype.hasB = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required int64 k = 3;
 * @return {number}
 */
proto.BATParameters.prototype.getK = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.setK = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.clearK = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATParameters.prototype.hasK = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required int64 q = 4;
 * @return {number}
 */
proto.BATParameters.prototype.getQ = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.setQ = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATParameters} returns this
 */
proto.BATParameters.prototype.clearQ = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATParameters.prototype.hasQ = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.BATKeys.prototype.toObject = function(opt_includeInstance) {
  return proto.BATKeys.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.BATKeys} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeys.toObject = function(includeInstance, msg) {
  var f, obj = {
    keyid: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    parameters: (f = msg.getParameters()) && proto.BATParameters.toObject(includeInstance, f),
    pk: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
    sk: (f = jspb.Message.getField(msg, 4)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.BATKeys}
 */
proto.BATKeys.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.BATKeys;
  return proto.BATKeys.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.BATKeys} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.BATKeys}
 */
proto.BATKeys.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setKeyid(value);
      break;
    case 2:
      var value = new proto.BATParameters;
      reader.readMessage(value,proto.BATParameters.deserializeBinaryFromReader);
      msg.setParameters(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPk(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setSk(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.BATKeys.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.BATKeys.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.BATKeys} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeys.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getParameters();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.BATParameters.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string keyId = 1;
 * @return {string}
 */
proto.BATKeys.prototype.getKeyid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.BATKeys} returns this
 */
proto.BATKeys.prototype.setKeyid = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeys} returns this
 */
proto.BATKeys.prototype.clearKeyid = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeys.prototype.hasKeyid = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required BATParameters parameters = 2;
 * @return {!proto.BATParameters}
 */
proto.BATKeys.prototype.getParameters = function() {
  return /** @type{!proto.BATParameters} */ (
    jspb.Message.getWrapperField(this, proto.BATParameters, 2, 1));
};


/**
 * @param {!proto.BATParameters} value
 * @return {!proto.BATKeys} returns this
*/
proto.BATKeys.prototype.setParameters = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeys} returns this
 */
proto.BATKeys.prototype.clearParameters = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeys.prototype.hasParameters = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required string pk = 3;
 * @return {string}
 */
proto.BATKeys.prototype.getPk = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.BATKeys} returns this
 */
proto.BATKeys.prototype.setPk = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeys} returns this
 */
proto.BATKeys.prototype.clearPk = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeys.prototype.hasPk = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required string sk = 4;
 * @return {string}
 */
proto.BATKeys.prototype.getSk = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.BATKeys} returns this
 */
proto.BATKeys.prototype.setSk = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeys} returns this
 */
proto.BATKeys.prototype.clearSk = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeys.prototype.hasSk = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.BATKeygenResult.prototype.toObject = function(opt_includeInstance) {
  return proto.BATKeygenResult.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.BATKeygenResult} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeygenResult.toObject = function(includeInstance, msg) {
  var f, obj = {
    keys: (f = msg.getKeys()) && proto.BATKeys.toObject(includeInstance, f),
    entry: (f = msg.getEntry()) && proto.Entry.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.BATKeygenResult}
 */
proto.BATKeygenResult.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.BATKeygenResult;
  return proto.BATKeygenResult.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.BATKeygenResult} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.BATKeygenResult}
 */
proto.BATKeygenResult.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.BATKeys;
      reader.readMessage(value,proto.BATKeys.deserializeBinaryFromReader);
      msg.setKeys(value);
      break;
    case 2:
      var value = new proto.Entry;
      reader.readMessage(value,proto.Entry.deserializeBinaryFromReader);
      msg.setEntry(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.BATKeygenResult.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.BATKeygenResult.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.BATKeygenResult} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeygenResult.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKeys();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.BATKeys.serializeBinaryToWriter
    );
  }
  f = message.getEntry();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.Entry.serializeBinaryToWriter
    );
  }
};


/**
 * required BATKeys keys = 1;
 * @return {!proto.BATKeys}
 */
proto.BATKeygenResult.prototype.getKeys = function() {
  return /** @type{!proto.BATKeys} */ (
    jspb.Message.getWrapperField(this, proto.BATKeys, 1, 1));
};


/**
 * @param {!proto.BATKeys} value
 * @return {!proto.BATKeygenResult} returns this
*/
proto.BATKeygenResult.prototype.setKeys = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeygenResult} returns this
 */
proto.BATKeygenResult.prototype.clearKeys = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeygenResult.prototype.hasKeys = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required Entry entry = 2;
 * @return {!proto.Entry}
 */
proto.BATKeygenResult.prototype.getEntry = function() {
  return /** @type{!proto.Entry} */ (
    jspb.Message.getWrapperField(this, proto.Entry, 2, 1));
};


/**
 * @param {!proto.Entry} value
 * @return {!proto.BATKeygenResult} returns this
*/
proto.BATKeygenResult.prototype.setEntry = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeygenResult} returns this
 */
proto.BATKeygenResult.prototype.clearEntry = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeygenResult.prototype.hasEntry = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.BATKeygenParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.BATKeygenParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.BATKeygenParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeygenParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f),
    parameters: (f = msg.getParameters()) && proto.BATParameters.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.BATKeygenParameters}
 */
proto.BATKeygenParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.BATKeygenParameters;
  return proto.BATKeygenParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.BATKeygenParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.BATKeygenParameters}
 */
proto.BATKeygenParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    case 2:
      var value = new proto.BATParameters;
      reader.readMessage(value,proto.BATParameters.deserializeBinaryFromReader);
      msg.setParameters(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.BATKeygenParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.BATKeygenParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.BATKeygenParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeygenParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
  f = message.getParameters();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.BATParameters.serializeBinaryToWriter
    );
  }
};


/**
 * required AuthToken token = 1;
 * @return {!proto.AuthToken}
 */
proto.BATKeygenParameters.prototype.getToken = function() {
  return /** @type{!proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 1, 1));
};


/**
 * @param {!proto.AuthToken} value
 * @return {!proto.BATKeygenParameters} returns this
*/
proto.BATKeygenParameters.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeygenParameters} returns this
 */
proto.BATKeygenParameters.prototype.clearToken = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeygenParameters.prototype.hasToken = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required BATParameters parameters = 2;
 * @return {!proto.BATParameters}
 */
proto.BATKeygenParameters.prototype.getParameters = function() {
  return /** @type{!proto.BATParameters} */ (
    jspb.Message.getWrapperField(this, proto.BATParameters, 2, 1));
};


/**
 * @param {!proto.BATParameters} value
 * @return {!proto.BATKeygenParameters} returns this
*/
proto.BATKeygenParameters.prototype.setParameters = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeygenParameters} returns this
 */
proto.BATKeygenParameters.prototype.clearParameters = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeygenParameters.prototype.hasParameters = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.BATExecution.prototype.toObject = function(opt_includeInstance) {
  return proto.BATExecution.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.BATExecution} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATExecution.toObject = function(includeInstance, msg) {
  var f, obj = {
    keys: (f = msg.getKeys()) && proto.BATKeys.toObject(includeInstance, f),
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f),
    iterations: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.BATExecution}
 */
proto.BATExecution.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.BATExecution;
  return proto.BATExecution.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.BATExecution} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.BATExecution}
 */
proto.BATExecution.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.BATKeys;
      reader.readMessage(value,proto.BATKeys.deserializeBinaryFromReader);
      msg.setKeys(value);
      break;
    case 2:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setIterations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.BATExecution.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.BATExecution.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.BATExecution} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATExecution.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKeys();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.BATKeys.serializeBinaryToWriter
    );
  }
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * required BATKeys keys = 1;
 * @return {!proto.BATKeys}
 */
proto.BATExecution.prototype.getKeys = function() {
  return /** @type{!proto.BATKeys} */ (
    jspb.Message.getWrapperField(this, proto.BATKeys, 1, 1));
};


/**
 * @param {!proto.BATKeys} value
 * @return {!proto.BATExecution} returns this
*/
proto.BATExecution.prototype.setKeys = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATExecution} returns this
 */
proto.BATExecution.prototype.clearKeys = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATExecution.prototype.hasKeys = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required AuthToken token = 2;
 * @return {!proto.AuthToken}
 */
proto.BATExecution.prototype.getToken = function() {
  return /** @type{!proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 2, 1));
};


/**
 * @param {!proto.AuthToken} value
 * @return {!proto.BATExecution} returns this
*/
proto.BATExecution.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATExecution} returns this
 */
proto.BATExecution.prototype.clearToken = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATExecution.prototype.hasToken = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required int64 iterations = 3;
 * @return {number}
 */
proto.BATExecution.prototype.getIterations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.BATExecution} returns this
 */
proto.BATExecution.prototype.setIterations = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATExecution} returns this
 */
proto.BATExecution.prototype.clearIterations = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATExecution.prototype.hasIterations = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.BATKeyImport.prototype.toObject = function(opt_includeInstance) {
  return proto.BATKeyImport.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.BATKeyImport} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeyImport.toObject = function(includeInstance, msg) {
  var f, obj = {
    keys: (f = msg.getKeys()) && proto.BATKeys.toObject(includeInstance, f),
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.BATKeyImport}
 */
proto.BATKeyImport.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.BATKeyImport;
  return proto.BATKeyImport.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.BATKeyImport} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.BATKeyImport}
 */
proto.BATKeyImport.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.BATKeys;
      reader.readMessage(value,proto.BATKeys.deserializeBinaryFromReader);
      msg.setKeys(value);
      break;
    case 2:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.BATKeyImport.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.BATKeyImport.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.BATKeyImport} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BATKeyImport.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKeys();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.BATKeys.serializeBinaryToWriter
    );
  }
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
};


/**
 * required BATKeys keys = 1;
 * @return {!proto.BATKeys}
 */
proto.BATKeyImport.prototype.getKeys = function() {
  return /** @type{!proto.BATKeys} */ (
    jspb.Message.getWrapperField(this, proto.BATKeys, 1, 1));
};


/**
 * @param {!proto.BATKeys} value
 * @return {!proto.BATKeyImport} returns this
*/
proto.BATKeyImport.prototype.setKeys = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeyImport} returns this
 */
proto.BATKeyImport.prototype.clearKeys = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeyImport.prototype.hasKeys = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required AuthToken token = 2;
 * @return {!proto.AuthToken}
 */
proto.BATKeyImport.prototype.getToken = function() {
  return /** @type{!proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 2, 1));
};


/**
 * @param {!proto.AuthToken} value
 * @return {!proto.BATKeyImport} returns this
*/
proto.BATKeyImport.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.BATKeyImport} returns this
 */
proto.BATKeyImport.prototype.clearToken = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BATKeyImport.prototype.hasToken = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CTRUParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.CTRUParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CTRUParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    n: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    q: (f = jspb.Message.getField(msg, 2)) == null ? undefined : f,
    q2: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
    eta: (f = jspb.Message.getField(msg, 4)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CTRUParameters}
 */
proto.CTRUParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CTRUParameters;
  return proto.CTRUParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CTRUParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CTRUParameters}
 */
proto.CTRUParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setN(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setQ(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setQ2(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setEta(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CTRUParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CTRUParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CTRUParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeInt64(
      4,
      f
    );
  }
};


/**
 * required int64 n = 1;
 * @return {number}
 */
proto.CTRUParameters.prototype.getN = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.setN = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.clearN = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUParameters.prototype.hasN = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required int64 q = 2;
 * @return {number}
 */
proto.CTRUParameters.prototype.getQ = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.setQ = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.clearQ = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUParameters.prototype.hasQ = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required int64 q2 = 3;
 * @return {number}
 */
proto.CTRUParameters.prototype.getQ2 = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.setQ2 = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.clearQ2 = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUParameters.prototype.hasQ2 = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required int64 eta = 4;
 * @return {number}
 */
proto.CTRUParameters.prototype.getEta = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/**
 * @param {number} value
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.setEta = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUParameters} returns this
 */
proto.CTRUParameters.prototype.clearEta = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUParameters.prototype.hasEta = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CTRUKeys.prototype.toObject = function(opt_includeInstance) {
  return proto.CTRUKeys.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CTRUKeys} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeys.toObject = function(includeInstance, msg) {
  var f, obj = {
    keyid: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
    parameters: (f = msg.getParameters()) && proto.CTRUParameters.toObject(includeInstance, f),
    pk: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
    sk: (f = jspb.Message.getField(msg, 4)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CTRUKeys}
 */
proto.CTRUKeys.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CTRUKeys;
  return proto.CTRUKeys.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CTRUKeys} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CTRUKeys}
 */
proto.CTRUKeys.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setKeyid(value);
      break;
    case 2:
      var value = new proto.CTRUParameters;
      reader.readMessage(value,proto.CTRUParameters.deserializeBinaryFromReader);
      msg.setParameters(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPk(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setSk(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CTRUKeys.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CTRUKeys.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CTRUKeys} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeys.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getParameters();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.CTRUParameters.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string keyId = 1;
 * @return {string}
 */
proto.CTRUKeys.prototype.getKeyid = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.CTRUKeys} returns this
 */
proto.CTRUKeys.prototype.setKeyid = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeys} returns this
 */
proto.CTRUKeys.prototype.clearKeyid = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeys.prototype.hasKeyid = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required CTRUParameters parameters = 2;
 * @return {!proto.CTRUParameters}
 */
proto.CTRUKeys.prototype.getParameters = function() {
  return /** @type{!proto.CTRUParameters} */ (
    jspb.Message.getWrapperField(this, proto.CTRUParameters, 2, 1));
};


/**
 * @param {!proto.CTRUParameters} value
 * @return {!proto.CTRUKeys} returns this
*/
proto.CTRUKeys.prototype.setParameters = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeys} returns this
 */
proto.CTRUKeys.prototype.clearParameters = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeys.prototype.hasParameters = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required string pk = 3;
 * @return {string}
 */
proto.CTRUKeys.prototype.getPk = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.CTRUKeys} returns this
 */
proto.CTRUKeys.prototype.setPk = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeys} returns this
 */
proto.CTRUKeys.prototype.clearPk = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeys.prototype.hasPk = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required string sk = 4;
 * @return {string}
 */
proto.CTRUKeys.prototype.getSk = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.CTRUKeys} returns this
 */
proto.CTRUKeys.prototype.setSk = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeys} returns this
 */
proto.CTRUKeys.prototype.clearSk = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeys.prototype.hasSk = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CTRUKeygenResult.prototype.toObject = function(opt_includeInstance) {
  return proto.CTRUKeygenResult.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CTRUKeygenResult} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeygenResult.toObject = function(includeInstance, msg) {
  var f, obj = {
    keys: (f = msg.getKeys()) && proto.CTRUKeys.toObject(includeInstance, f),
    entry: (f = msg.getEntry()) && proto.Entry.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CTRUKeygenResult}
 */
proto.CTRUKeygenResult.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CTRUKeygenResult;
  return proto.CTRUKeygenResult.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CTRUKeygenResult} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CTRUKeygenResult}
 */
proto.CTRUKeygenResult.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.CTRUKeys;
      reader.readMessage(value,proto.CTRUKeys.deserializeBinaryFromReader);
      msg.setKeys(value);
      break;
    case 2:
      var value = new proto.Entry;
      reader.readMessage(value,proto.Entry.deserializeBinaryFromReader);
      msg.setEntry(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CTRUKeygenResult.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CTRUKeygenResult.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CTRUKeygenResult} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeygenResult.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKeys();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.CTRUKeys.serializeBinaryToWriter
    );
  }
  f = message.getEntry();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.Entry.serializeBinaryToWriter
    );
  }
};


/**
 * required CTRUKeys keys = 1;
 * @return {!proto.CTRUKeys}
 */
proto.CTRUKeygenResult.prototype.getKeys = function() {
  return /** @type{!proto.CTRUKeys} */ (
    jspb.Message.getWrapperField(this, proto.CTRUKeys, 1, 1));
};


/**
 * @param {!proto.CTRUKeys} value
 * @return {!proto.CTRUKeygenResult} returns this
*/
proto.CTRUKeygenResult.prototype.setKeys = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeygenResult} returns this
 */
proto.CTRUKeygenResult.prototype.clearKeys = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeygenResult.prototype.hasKeys = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required Entry entry = 2;
 * @return {!proto.Entry}
 */
proto.CTRUKeygenResult.prototype.getEntry = function() {
  return /** @type{!proto.Entry} */ (
    jspb.Message.getWrapperField(this, proto.Entry, 2, 1));
};


/**
 * @param {!proto.Entry} value
 * @return {!proto.CTRUKeygenResult} returns this
*/
proto.CTRUKeygenResult.prototype.setEntry = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeygenResult} returns this
 */
proto.CTRUKeygenResult.prototype.clearEntry = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeygenResult.prototype.hasEntry = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CTRUKeygenParameters.prototype.toObject = function(opt_includeInstance) {
  return proto.CTRUKeygenParameters.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CTRUKeygenParameters} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeygenParameters.toObject = function(includeInstance, msg) {
  var f, obj = {
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f),
    parameters: (f = msg.getParameters()) && proto.CTRUParameters.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CTRUKeygenParameters}
 */
proto.CTRUKeygenParameters.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CTRUKeygenParameters;
  return proto.CTRUKeygenParameters.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CTRUKeygenParameters} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CTRUKeygenParameters}
 */
proto.CTRUKeygenParameters.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    case 2:
      var value = new proto.CTRUParameters;
      reader.readMessage(value,proto.CTRUParameters.deserializeBinaryFromReader);
      msg.setParameters(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CTRUKeygenParameters.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CTRUKeygenParameters.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CTRUKeygenParameters} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeygenParameters.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
  f = message.getParameters();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.CTRUParameters.serializeBinaryToWriter
    );
  }
};


/**
 * required AuthToken token = 1;
 * @return {!proto.AuthToken}
 */
proto.CTRUKeygenParameters.prototype.getToken = function() {
  return /** @type{!proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 1, 1));
};


/**
 * @param {!proto.AuthToken} value
 * @return {!proto.CTRUKeygenParameters} returns this
*/
proto.CTRUKeygenParameters.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeygenParameters} returns this
 */
proto.CTRUKeygenParameters.prototype.clearToken = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeygenParameters.prototype.hasToken = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required CTRUParameters parameters = 2;
 * @return {!proto.CTRUParameters}
 */
proto.CTRUKeygenParameters.prototype.getParameters = function() {
  return /** @type{!proto.CTRUParameters} */ (
    jspb.Message.getWrapperField(this, proto.CTRUParameters, 2, 1));
};


/**
 * @param {!proto.CTRUParameters} value
 * @return {!proto.CTRUKeygenParameters} returns this
*/
proto.CTRUKeygenParameters.prototype.setParameters = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeygenParameters} returns this
 */
proto.CTRUKeygenParameters.prototype.clearParameters = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeygenParameters.prototype.hasParameters = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CTRUExecution.prototype.toObject = function(opt_includeInstance) {
  return proto.CTRUExecution.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CTRUExecution} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUExecution.toObject = function(includeInstance, msg) {
  var f, obj = {
    keys: (f = msg.getKeys()) && proto.CTRUKeys.toObject(includeInstance, f),
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f),
    iterations: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CTRUExecution}
 */
proto.CTRUExecution.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CTRUExecution;
  return proto.CTRUExecution.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CTRUExecution} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CTRUExecution}
 */
proto.CTRUExecution.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.CTRUKeys;
      reader.readMessage(value,proto.CTRUKeys.deserializeBinaryFromReader);
      msg.setKeys(value);
      break;
    case 2:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setIterations(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CTRUExecution.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CTRUExecution.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CTRUExecution} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUExecution.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKeys();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.CTRUKeys.serializeBinaryToWriter
    );
  }
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * required CTRUKeys keys = 1;
 * @return {!proto.CTRUKeys}
 */
proto.CTRUExecution.prototype.getKeys = function() {
  return /** @type{!proto.CTRUKeys} */ (
    jspb.Message.getWrapperField(this, proto.CTRUKeys, 1, 1));
};


/**
 * @param {!proto.CTRUKeys} value
 * @return {!proto.CTRUExecution} returns this
*/
proto.CTRUExecution.prototype.setKeys = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUExecution} returns this
 */
proto.CTRUExecution.prototype.clearKeys = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUExecution.prototype.hasKeys = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required AuthToken token = 2;
 * @return {!proto.AuthToken}
 */
proto.CTRUExecution.prototype.getToken = function() {
  return /** @type{!proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 2, 1));
};


/**
 * @param {!proto.AuthToken} value
 * @return {!proto.CTRUExecution} returns this
*/
proto.CTRUExecution.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUExecution} returns this
 */
proto.CTRUExecution.prototype.clearToken = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUExecution.prototype.hasToken = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required int64 iterations = 3;
 * @return {number}
 */
proto.CTRUExecution.prototype.getIterations = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.CTRUExecution} returns this
 */
proto.CTRUExecution.prototype.setIterations = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUExecution} returns this
 */
proto.CTRUExecution.prototype.clearIterations = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUExecution.prototype.hasIterations = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CTRUKeyImport.prototype.toObject = function(opt_includeInstance) {
  return proto.CTRUKeyImport.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CTRUKeyImport} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeyImport.toObject = function(includeInstance, msg) {
  var f, obj = {
    keys: (f = msg.getKeys()) && proto.CTRUKeys.toObject(includeInstance, f),
    token: (f = msg.getToken()) && proto.AuthToken.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CTRUKeyImport}
 */
proto.CTRUKeyImport.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CTRUKeyImport;
  return proto.CTRUKeyImport.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CTRUKeyImport} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CTRUKeyImport}
 */
proto.CTRUKeyImport.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.CTRUKeys;
      reader.readMessage(value,proto.CTRUKeys.deserializeBinaryFromReader);
      msg.setKeys(value);
      break;
    case 2:
      var value = new proto.AuthToken;
      reader.readMessage(value,proto.AuthToken.deserializeBinaryFromReader);
      msg.setToken(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CTRUKeyImport.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CTRUKeyImport.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CTRUKeyImport} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CTRUKeyImport.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKeys();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.CTRUKeys.serializeBinaryToWriter
    );
  }
  f = message.getToken();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.AuthToken.serializeBinaryToWriter
    );
  }
};


/**
 * required CTRUKeys keys = 1;
 * @return {!proto.CTRUKeys}
 */
proto.CTRUKeyImport.prototype.getKeys = function() {
  return /** @type{!proto.CTRUKeys} */ (
    jspb.Message.getWrapperField(this, proto.CTRUKeys, 1, 1));
};


/**
 * @param {!proto.CTRUKeys} value
 * @return {!proto.CTRUKeyImport} returns this
*/
proto.CTRUKeyImport.prototype.setKeys = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeyImport} returns this
 */
proto.CTRUKeyImport.prototype.clearKeys = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeyImport.prototype.hasKeys = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required AuthToken token = 2;
 * @return {!proto.AuthToken}
 */
proto.CTRUKeyImport.prototype.getToken = function() {
  return /** @type{!proto.AuthToken} */ (
    jspb.Message.getWrapperField(this, proto.AuthToken, 2, 1));
};


/**
 * @param {!proto.AuthToken} value
 * @return {!proto.CTRUKeyImport} returns this
*/
proto.CTRUKeyImport.prototype.setToken = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.CTRUKeyImport} returns this
 */
proto.CTRUKeyImport.prototype.clearToken = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.CTRUKeyImport.prototype.hasToken = function() {
  return jspb.Message.getField(this, 2) != null;
};


goog.object.extend(exports, proto);
